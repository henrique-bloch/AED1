#include <stdio.h>
#include <stdlib.h>

typedef long long ll;

typedef struct {
    int u, v, w;
} Aresta;

// Comparação para ordenar por peso (distância) crescente
int comp(const void *a, const void *b) {
    Aresta *x = (Aresta*)a;
    Aresta *y = (Aresta*)b;
    return x->w - y->w;
}

int *pai, *rank;

// Busca o mestre do grupo com compressão de caminho
int achar(int x) {
    if (pai[x] == x) return x;
    return pai[x] = achar(pai[x]);
}

// Une dois grupos distintos
void unir(int a, int b) {
    a = achar(a);
    b = achar(b);
    if (a != b) {
        if (rank[a] < rank[b]) pai[a] = b;
        else if (rank[b] < rank[a]) pai[b] = a;
        else { pai[b] = a; rank[a]++; }
    }
}

int main() {
    int m, n; // m: cidades, n: estradas

    while (scanf("%d %d", &m, &n) == 2 && (m != 0 || n != 0)) {
        Aresta *e = (Aresta*)malloc(n * sizeof(Aresta));
        pai = (int*)malloc(m * sizeof(int));
        rank = (int*)malloc(m * sizeof(int));

        for (int i = 0; i < m; i++) {
            pai[i] = i;
            rank[i] = 0;
        }

        for (int i = 0; i < n; i++) {
            scanf("%d %d %d", &e[i].u, &e[i].v, &e[i].w);
        }

        // Algoritmo de Kruskal: ordenar e processar
        qsort(e, n, sizeof(Aresta), comp);

        ll peso_total = 0;
        int cont = 0;

        for (int i = 0; i < n && cont < m - 1; i++) {
            if (achar(e[i].u) != achar(e[i].v)) {
                unir(e[i].u, e[i].v);
                peso_total += e[i].w;
                cont++;
            }
        }

        printf("%lld\n", peso_total);

        free(e);
        free(pai);
        free(rank);
    }
    return 0;
}
